
'Delete existing waves in memory
PlayWaveDelete();

var virtDataHandle%;
var recDataHandle%;

var whiteNoise%;
var noisePer% := 60; 'Seconds, period of noise pattern repetition
var noiseVolume;
var prePulseVolume;
var pulseVolume;
var ok%;

var auto% := 0;
var noiseDb := 70;
var noiseDurSet% := 10; 'Minutes of white noise before experiment starts
' !!! var noiseDur% := 10; 'Minutes of white noise before experiment starts
var prePulseDb := 80;
var prePulseDur% := 50;
var ISI% := 100;
var pulseDb := 110;
var pulseDur% := 50;
var ITIset := 10;         'Sec
' !!! var ITI := 10;         'Sec
var ITIvar% := 5;
var numPrep% := 10;
var numPulse% := 10;
var numPair% := 10;
var blockSeq$ := "RPD";

var noiseAmp;
var prePulseAmp;
var pulseAmp;

Settings%();

var ITI := ITIset * 1000;                               'Convert seconds of ITI into ms
' !!! ITI *= 1000;                               'Convert seconds of ITI into ms
var ITIvarVal := ITI*ITIvar%/100.0;        'ITI variation in ms
ITI -= ITIvarVal;                          'Give room for ITIvar

var bits%;
if ITIvarVal <> 0 then
    bits% := Round(Ln(ITIvarVal)/Ln(2));        '0 causes error in the logarithm
else
    bits% := 0;
endif;


var noiseDur% := noiseDurSet% * 60;        'Convert mins to secs
' !!! noiseDur% *= 60;        'Convert mins to secs
var noiseLoop% := noiseDur%/noisePer%;
var ITIloop% := ITI/(noisePer%*1000); 
var varLoop% := ITIvarVal/(noisePer%*1000); 

makeWaves();
WriteSequence%();

'Create new file for data 
recDataHandle% := FileNew(0);
FrontView(recDataHandle%);

DoToolbar();  

func DoToolbar() 
ToolbarClear();  
  
ToolbarSet(1, "Stop", Stop%);     
ToolbarSet(2, "Start", Start%); 
ToolBarSet(3, "Settings", Settings%);

ToolbarEnable(1,1);
ToolbarEnable(2,1);
ToolbarEnable(3,1);
return Toolbar("Experiment control", 2 + 128);
end;


'Create settings dialog box
func Settings%()  

DlgCreate("Settings");  'Start new dialog

DlgButton(2,"Load settings",LoadSettings%,2,1);
DlgCheck(1,"Enable automatic program",0,2);
DlgInteger(2,"Background volume (50-115 dB)",50,115,0,3);
DlgInteger(3,"Noise duration (min)",0,600,0,4);

DlgInteger(4,"Prepulse volume (50-115 dB)",50,115,0,6);
DlgInteger(5,"Prepulse duration (0-100 ms)",0,100,0,7);
DlgInteger(6,"Number of prepulses",0,100,0,8);

DlgInteger(7,"Pulse volume (50-115 dB)",50,115,0,10);
DlgInteger(8,"Pulse duration (0-100 ms)",0,100,0,11);
DlgInteger(9,"Number of pulses",0,100,0,12);

DlgInteger(10,"Prepulse-pulse interval (ISI) (ms)",0,1000,0,14);
DlgInteger(11,"Number of prepulse-pulse pairs",0,100,0,15);

DlgReal(12,"Inter-trial interval (ITI) (1-30 s)",1,30,0,17);
DlgInteger(13,"ITI variation (0-100%)",0,100,0,18);

DlgString(14,"Sequence of blocks",10,"RPD",0,20);
DlgText("R - pRepulse, P - Pulse, D - Double",0,21);

DlgButton(3,"Save settings", SaveSettings%);
DlgButton(0,"Cancel");
DlgButton(1,"OK");

'Enable/disable dialogue items for automatic program 
DlgAllow(0x3ff, 0, Change%);

ok% := DlgShow(auto%, noiseDb, noiseDurSet%, prePulseDb, prePulseDur%, numPrep%, 
pulseDb, pulseDur%, numPulse%, ISI%, numPair%, ITIset, ITIvar%, blockSeq$); 
' !!! ok% := DlgShow(auto%, noiseDb, noiseDur%, prePulseDb, prePulseDur%, numPrep%, 
' !!! pulseDb, pulseDur%, numPulse%, ISI%, numPair%, ITI, ITIvar%, blockSeq$); 
'ok% is 0 if user cancels, variables updated if not
if ok% = 0 then 'If Cancel don't enter sampling
    halt;
endif;

return 1;
end;


'Automatic/manual settings dialogue box
func Change%(item%)
var v%;
docase
    case ((item% = 1) or (item% = 0)) then '0 is initial setup
        v% := DlgValue(1);        'Get check box state
        DlgEnable(v%, 3, 6, 9, 11, 12, 13, 14); 'Enable automatic variables
endcase; 
return 1;                     'Return 1 to keep dialog running
end;

func LoadSettings%()
FileOpen("",8,0);

'Read settings from chosen file
var n% := Read(auto%, noiseDb, noiseDurSet%, prePulseDb, prePulseDur%, ISI%, pulseDb, pulseDur%,
ITIset, ITIvar%, numPrep%, numPulse%, numPair%, blockSeq$);
' !!! var n% := Read(auto%, noiseDb, noiseDur%, prePulseDb, prePulseDur%, ISI%, pulseDb, pulseDur%,
' !!! ITI, ITIvar%, numPrep%, numPulse%, numPair%, blockSeq$);

'Update all dialogue values with settings from file
DlgValue(1,auto%); DlgValue(2,noiseDb); DlgValue(3,noiseDurSet%); DlgValue(4,prePulseDb);
' !!! DlgValue(1,auto%); DlgValue(2,noiseDb); DlgValue(3,noiseDur%); DlgValue(4,prePulseDb);
DlgValue(5,prePulseDur%); DlgValue(6,ISI%); DlgValue(7,pulseDb); DlgValue(8,pulseDur%);
DlgValue(9,ITIset); DlgValue(10,ITIvar%); DlgValue(11,numPrep%); DlgValue(12,numPulse%); 
' !!! DlgValue(9,ITI); DlgValue(10,ITIvar%); DlgValue(11,numPrep%); DlgValue(12,numPulse%); 
DlgValue(13,numPair%); DlgValue$(14,blockSeq$);

'Toggle "Enable automatic program" checkbox
Change%(1);

FileClose();  
return 1;
end;

func SaveSettings%() 
FileNew(1);

'Print current dialogue values into new file
var i%;
for i% := 1 to 13 do
    Print("%f,", DlgValue(i%));
next;
Print("%s", DlgValue$(14));

'Prompt user to save the file with settings
FileSaveAs("");
FileClose();
return 1;
end;

'Start experiment
func Start%()

Resume%();               'Set pause status off

SampleStart();           'Start sampling
SampleKey("s");          'Play background noise

ToolbarEnable(1,1); 'Stop
ToolbarSet(2, "Pause", Pause%);

return 1;
end;

'Pause sampling
func Pause%()
ToolbarSet(2, "Resume", Resume%);
SampleKey("h");
return 1;
end;

'Resume after pause
func Resume%()
ToolbarSet(2, "Pause", Pause%);
SampleKey("s");

return 1;
end;

'Stop sampling
func Stop%()  

SampleStop();         'Stop sampling
SampleKey("h");       'Stop the sequencer

return 0; 
end;

proc makeWaves()

Var ExpN$;   'Virtual channel expression for background noize
Var ExpR$;   'Virtual channel expression for prepulse
Var ExpP$;   'Virtual channel expression for pulse

Var DAC%:=0;    'Output DAC

Var memN%;   'Memory channel for noise 
Var memR%;   'Memory channel for prepulse
Var memP%;   'Memory channel for pulse

'Var Err%;
Var Noise[0];   'Array for generated white noise

'Create new file for virtual data
virtDataHandle%:=FileNew(7,2,5,1,10);           'upt = 5 us

MemDeleteItem(memN%);
MemDeleteItem(memR%);
MemDeleteItem(memP%);
 
memN% := Memchan(1, 0, 0.00002);          '4 times larger than 'upt' argument of FileNew()
memR% := Memchan(1, 0, 0.00002);                                                       
memP% := Memchan(1, 0, 0.00002);

noiseAmp := Db2Amp(noiseDb);
prePulseAmp := Db2Amp(prePulseDb);
pulseAmp := Db2Amp(pulseDb);

'Generate noise sequence for background noise
Resize Noise[noisePer%/Binsize(memN%)];    
Rand(Noise[], 2*noiseAmp, -noiseAmp);   '2*noiseAmp - scale of the random number; -noiseAmp - offset of the random number
Memsetitem(memN%, 0, 0, Noise[]); 

const nMax% := 1000000;
var wave[nMax%]; 'Real and integer wave, first time
var n% := ChanData(memN%, wave, 0, MaxTime(memN%)); 

'Generate noise sequence for prepulse
Resize Noise[prePulseDur%/Binsize(memR%)];    
Rand(Noise[], 2*prePulseAmp, -prePulseAmp);
Memsetitem(memR%, 0, 0, Noise[]); 

'Generate noise sequence for pulse
Resize Noise[pulseDur%/Binsize(memP%)];    
Rand(Noise[], 2*pulseAmp, -pulseAmp);
Memsetitem(memP%, 0, 0, Noise[]); 

var virtChanN:=VirtualChan(0,"",memN%);
var virtChanR:=VirtualChan(0,"",memR%);
var virtChanP:=VirtualChan(0,"",memP%);
    
ExpN$:=Print$("Ch(%d)", memN%); 'Form envelope
VirtualChan(virtChanN, "", 0, Binsize(memN%)); 'Set the sample rate to match memory channel, or else DAC output will be trimmed
VirtualChan(virtChanN, ExpN$);   'Write the expression
ChanTitle$(virtChanN,"Noise");
PlayWaveAdd("N", "Noise", DAC%, 0, noisePer%, virtChanN, 1); 'Add the waveform to the list

ExpR$:=Print$("Ch(%d)", memR%); 'Form envelope
VirtualChan(virtChanR, "", 0, Binsize(memR%)); 'Set the sample rate to match memory channel, or else DAC output will be trimmed
VirtualChan(virtChanR, ExpR$);   'Write the expression
ChanTitle$(virtChanN,"Prepulse");
PlayWaveAdd("R", "Prepulse", DAC%, 0, prePulseDur%, virtChanR, 1); 'Add the waveform to the list

ExpP$:=Print$("Ch(%d)", memP%); 'Form envelope
VirtualChan(virtChanP, "", 0, Binsize(memP%)); 'Set the sample rate to match memory channel, or else DAC output will be trimmed
VirtualChan(virtChanP, ExpP$);   'Write the expression
ChanTitle$(virtChanP,"Pulse");
PlayWaveAdd("P", "Pulse", DAC%, 0, pulseDur%, virtChanP, 1); 'Add the waveform to the list

PrintLog(SampleHandle(0));
'After data has been loaded, close the view with the virtual waveforms
View(virtDataHandle%);
FileClose(0,-1);

return;
end;

'Convert sound volume in decibels into voltage amplitude
func Db2Amp(db)    

'   db - sound level in decibels set by user
'   volume - percent of the maximal output voltage amplitude on the given apparatus
'   amplitude - output voltage amplitude
'
'   Calibration:
'   1.  Assign 
'       var volume := db;
'   2.  Set "Background volume" in the Settings dialogue box in the range 1-100
'       and measure the actual sound volume in the apparatus' chamber with a sound level meter
'       ! It is important to measure the sound level on a steady noise rather than short pulses, 
'         as the time of the pulse might not be enough for a sound level meter to measure it correctly
'       2.1.    Set "Background volume" as 100. 
'               If you use a sound amplifier, set its own volume to the lowest level that yields 
'               the maximal sound volume necessary in the experiment (e.g. 120 db)
'       2.2.    Set "Background volume" in the range 1-100 with a small step.
'               For each value measure the corresponding sound level
'               ! It may be necessary to adjust the sound level meter's settings to different sound volume ranges
'   3.  Plot sound level as a function of the "Background volume" in the range 1-100.
'       Make a logarithmic approximation (e.g. in the MS Excel)
'   4.  Take the values of "a" and "b" from the resulting equation in the format y=a*ln(x)+b,
'       where y=db, and x=volume.
'   5.  Assign the values to the variables "a" and "b" below, reassign "volume" to the formula

var a := 9.7861;
var b := 72.061;

'Comment for calibration:
var volume := Pow(_e,(db-b)/a);
'Uncomment for calibration:
'var volume := db;

var maxVoltage := 2;    'Maximal output voltage on the given apparatus
var amplitude := maxVoltage*volume/100; 
return amplitude;
end;


func WriteSequence%()
var Seq%; 'Sequence file handle
var Err%; 'Error check
var Path$;
Const Seq$ := "PPI_Seq.pls";

Path$ := View(App(3)).Filename$(1)+View(App(3)).Filename$(2); 'Path is the location of this script

Seq% := Filenew(2, 0);
If seq% < 0 then
    Message("Sequence file could not be produced. Halting");
    halt;
endif

View(Seq%);

Print("                SET    1,1,0\n");
Print("                VAR    V1\n"); 
Print("                VAR    V2\n");
Print("                VAR    V3\n");
Print("                VAR    V4\n");
Print("                VAR    V5\n");
Print("                VAR    V6\n");

Print("HH:    'h       WAVEST S\n");    
Print("                HALT\n");

WriteNoise();

if auto% then    
    
    var a%;
    for a% := 0 to len(blockSeq$) do
        docase
            case Left$(blockSeq$, 1) = "R" then
                Print("                MOVI V2, %d\n",numPrep%);
                Print("                CALL RL\n"); 
            case Left$(blockSeq$, 1) = "P" then
                Print("                MOVI V3, %d\n",numPulse%);
                Print("                CALL PL\n");
            case Left$(blockSeq$, 1) = "D" then
                Print("                MOVI V4, %d\n",numPair%);
                Print("                CALL DL\n");
        endcase;
        blockSeq$ := DelStr$(blockSeq$, 1, 1);
    next;
    Print("                JUMP HH\n");
    WriteITI();
    
else
    Print("PP:  'r         CALL RL\n");    
    Print("                JUMP ST\n");
    Print("PU:  'p         CALL PL\n");    
    Print("                JUMP ST\n");
    Print("PA:  'd         CALL DL\n");    
    Print("                JUMP ST\n");
endif;    

    WritePrepulses();
    WritePulses();
    WriteDoubles();
    
Err%:=FileSaveAs(Path$+Seq$, 2, 1);
FileClose(0);
Err%:=SampleSequencer(Path$+Seq$);

If err% < 0 then
    Message("Sequencer failed to load. Halting");
    Halt
endif

return 1
end

proc WriteNoise()

'Play background white noise
Print("ST:    's       MOVI V1, %d\n",noiseLoop%);

if noiseLoop% <> 0 then
    Print("NL:             WAVEGO N,TW\n");
    Print("                WAVEST T\n"); 'Start noise
    Print("                DELAY s(%d)\n",noisePer%);
    Print("                WAVEST S\n");
    Print("                DBNZ V1, NL\n"); 'Play as many noise periods as fit in noiseDur
endif;

if noiseDur% mod noisePer% <> 0 then
    Print("                WAVEGO N,TW\n");
    Print("                WAVEST T\n");
    Print("                DELAY s(%d)\n",noiseDur% mod noisePer%); 'Play the remaining ITI time (in case there are no whole number of noise periods in one ITI)
    Print("                WAVEST S\n");
endif;

if not auto% then
    Print("                JUMP ST\n");
endif;

return;
end;

proc WritePrepulses()

'Prepulse
Print("RL:             WAVEGO R,TW\n");
Print("                WAVEST T\n"); 'Start prepulse
Print("                DELAY ms(%d)\n",PrePulseDur%);
Print("                WAVEST S\n"); 'Stop prepulse

if auto% then
    Print("                CALL IT\n");
    Print("                DBNZ V2,RL\n");
endif;
Print("                RETURN\n");

return;
end;

proc WritePulses()

'Pulse
Print("PL:             WAVEGO P,TW\n");      'Set pulse waveform
Print("                WAVEST T\n");         'Start pulse
Print("                DELAY ms(%d)\n",pulseDur%);
Print("                WAVEST S\n");         'Stop pulse

if auto% then
    Print("                CALL IT\n");
    Print("                DBNZ V3,PL\n");
endif;
Print("                RETURN\n"); 


return;
end;

proc WriteDoubles()

'Pair prepulse-pulse
    'Run prepulse
Print("DL:             WAVEGO R,TW\n");
Print("                WAVEST T\n"); 'Start prepulse
Print("                DELAY ms(%d)\n",PrePulseDur%);
    'Run background noise during ISI
Print("                WAVEGO N,TW\n");
Print("                WAVEST T\n"); 'Start noise
Print("                DELAY ms(%d)\n",ISI%);
    'Run pulse
Print("                WAVEGO P, TW\n"); 'Set pulse waveform
Print("                WAVEST T\n"); 'Start pulse
Print("                DELAY ms(%d)\n",pulseDur%);
Print("                WAVEST S\n");         'Stop pulse

if auto% then
    Print("                CALL IT\n");
    Print("                DBNZ V4,DL\n");
endif;    
Print("                RETURN\n");


return;
end;

proc WriteITI()

'ITI
Print("IT:             MOVI V5, %d\n",ITIloop%);
if ITIloop% <> 0 then
    Print("TL:             WAVEGO N,TW\n");
    Print("                WAVEST T\n");        'Start noise
    Print("                DELAY s(%d)\n",noisePer%);
    Print("                WAVEST S\n");
    Print("                DBNZ V5, TL\n");     'Play as many noise periods as fits in the ITI
endif;

if ITI mod (noisePer%*1000) <> 0 then
    Print("                WAVEGO N,TW\n");
    Print("                WAVEST T\n");
    Print("                DELAY ms(%d)\n",ITI mod (noisePer%*1000)); 'Play the remaining ITI time (in case there is no whole number of noise periods in one ITI)
    Print("                WAVEST S\n");
endif;

if bits% <> 0 then
    Print("                MOVRND V6,%d,-%d\n", bits%+1, bits%);
    Print("                WAVEGO N,TW\n");
    Print("                WAVEST T\n");        'Start noise
    Print("                DELAY V6\n");        'ASSUMING msPerStep OF SET =1 (ms). IT WILL GO WRONG OTHERWISE 
    Print("                WAVEST S\n");
endif;

Print("                RETURN\n");

return;
end;